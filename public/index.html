<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questionnaire QVT - AudiRep</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chatbot-container {
            width: 400px;
            height: 600px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .chatbot-header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .chatbot-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .chatbot-header .status {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            margin-top: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.3s ease;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #f8f9fa;
        }

        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
            animation: fadeIn 0.3s ease-in;
        }

        .message.user {
            background: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .message.bot {
            background: white;
            color: #333;
            align-self: flex-start;
            border: 1px solid #e9ecef;
            border-bottom-left-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: white;
            padding: 12px 16px;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #999;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        .chat-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input:focus {
            border-color: #007bff;
        }

        .chat-input:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .send-button {
            width: 45px;
            height: 45px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }

        .send-button:hover {
            background: #0056b3;
            transform: scale(1.05);
        }

        .send-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        .input-blocked {
            pointer-events: none;
            opacity: 0.5;
        }

        .radio-options {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            align-self: flex-start;
            max-width: 90%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .radio-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 6px;
            margin: 5px 0;
        }

        .radio-option:hover {
            background-color: #f8f9fa;
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #007bff;
        }

        .radio-option label {
            cursor: pointer;
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .radio-submit-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            margin-top: 15px;
            transition: background-color 0.2s;
            width: 100%;
        }

        .radio-submit-btn:hover {
            background: #0056b3;
        }

        .radio-submit-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        /* Styles pour les boutons de notation */
        .rating-options {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            align-self: flex-start;
            max-width: 90%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .rating-title {
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
            text-align: center;
        }

        .rating-buttons {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 15px;
        }

        .rating-btn {
            width: 45px;
            height: 45px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            color: #6c757d;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rating-btn:hover {
            border-color: #007bff;
            color: #007bff;
            transform: scale(1.1);
        }

        .rating-btn.selected {
            border-color: #007bff;
            background: #007bff;
            color: white;
            animation: pulse 0.3s;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .rating-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
            margin-bottom: 15px;
            padding: 0 5px;
        }

        .completion-message {
            background: #28a745;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 10px;
            margin: 20px;
            display: none;
        }

        .error-message {
            background: #dc3545;
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 12px;
            display: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        @media (max-width: 480px) {
            .chatbot-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div class="chatbot-container">
        <div class="chatbot-header">
            <h3>üìã Enqu√™te Qualit√© de Vie au Travail</h3>
            <div class="status" id="statusText">En cours...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        
        <div class="completion-message" id="completionMessage">
            <h4>‚úÖ Questionnaire termin√© !</h4>
            <p>Merci pour votre participation. Vos r√©ponses ont √©t√© enregistr√©es.</p>
        </div>
        
        <div class="chat-messages" id="chatMessages"></div>
        
        <div class="typing-indicator" id="typingIndicator">
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="chat-input-container" id="inputContainer">
            <div class="chat-input-wrapper">
                <input 
                    type="text" 
                    class="chat-input" 
                    id="chatInput" 
                    placeholder="Tapez votre r√©ponse..."
                    maxlength="2000"
                >
                <button class="send-button" id="sendButton">
                    ‚û§
                </button>
            </div>
        </div>
    </div>

        <script>
        (function () {
            class SurveyChatbot {
                constructor() {
                    this.chatMessages = document.getElementById('chatMessages');
                    this.chatInput = document.getElementById('chatInput');
                    this.sendButton = document.getElementById('sendButton');
                    this.typingIndicator = document.getElementById('typingIndicator');
                    this.errorMessage = document.getElementById('errorMessage');
                    this.completionMessage = document.getElementById('completionMessage');
                    this.inputContainer = document.getElementById('inputContainer');
                    this.progressFill = document.getElementById('progressFill');
                    this.statusText = document.getElementById('statusText');

                    this.sessionId = 'survey_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                    this.systemPrompt = `Tu es un chatbot QVT. Tu accompagnes un collaborateur au fil d'un questionnaire structur√© sur la qualit√© de vie au travail.\n\nTon style doit √™tre concis, chaleureux et direct. Utilise des emojis avec parcimonie pour illustrer sans alourdir. Tu peux ajouter une pointe d'humour l√©g√®re quand c'est pertinent.\n\nTu n'√©nonces qu'une seule action √† la fois : introduction, transition, relance, r√©action √† une note parfaite ou message de cl√¥ture. Chaque fois, reste bref et engageant.\n\nLorsque tu r√©diges une introduction, rappelle la nature du questionnaire (questions ouvertes et not√©es de 1 √† 5), l'√©chelle 1 = avis le plus n√©gatif / 5 = avis le plus positif, et encourage la sinc√©rit√©.\n\nLorsque tu r√©diges une transition, annonce simplement le nouveau th√®me sans r√©p√©ter les titres complets re√ßus et sans d√©voiler les questions.\n\nLorsque tu r√©diges une relance apr√®s une note faible 1 ou 2, pose exactement une question ouverte s√©rieuse et (IMPORTANT) **sans humour**, sans proposer d'autre relance ensuite. Ton objectif est de bien **comprendre pourquoi la note est faible**.\n\nLorsque tu r√©diges une r√©action suite √† une note de 5/5, f√©licite bri√®vement, reste enthousiaste et ajoute une touche d'humour sans poser de question ni lancer d'action suppl√©mentaire.\n\nLorsque tu r√©diges le message final, remercie et termine imp√©rativement par la phrase : 'Ceci conclut notre entretien. Merci pour votre participation.'`;

                    this.aiConversation = [
                        {
                            role: 'system',
                            content: this.systemPrompt
                        }
                    ];

                    this.questions = [];
                    this.currentQuestionIndex = 0;
                    this.currentQuestion = null;
                    this.previousSectionId = null;
                    this.awaitingFollowup = false;
                    this.pendingFollowupQuestion = null;
                    this.pendingFollowupEntry = null;
                    this.lastRatingValue = null;
                    this.completedMainQuestions = 0;
                    this.totalMainQuestions = 0;
                    this.responses = [];
                    this.answersById = {};
                    this.timestampStart = null;
                    this.timestampEnd = null;
                    this.isCompleted = false;
                    this.botIsResponding = false;
                    this.typingDelayConfig = {
                        min: 600,
                        max: 1800,
                        perChar: 28
                    };
                    this.perfectScoreReactionChance = 1 / 2;
                    this.followupReactionToggle = false;

                    this.initializeEventListeners();
                    this.loadAndStart();
                }

                initializeEventListeners() {
                    this.sendButton.addEventListener('click', () => {
                        if (!this.botIsResponding) {
                            this.sendMessage();
                        }
                    });

                    this.handleEnterKey = (event) => {
                        if (event.key === 'Enter' && !event.shiftKey) {
                            event.preventDefault();
                            if (!this.botIsResponding) {
                                this.sendMessage();
                            }
                        }
                    };

                    this.chatInput.addEventListener('keypress', this.handleEnterKey);
                    this.chatInput.addEventListener('input', () => {
                        this.sendButton.disabled = this.chatInput.value.trim() === '';
                    });
                }

                async loadAndStart() {
                    try {
                        await this.loadQuestions();
                        await this.startInterview();
                    } catch (error) {
                        console.error('Erreur lors du d√©marrage du questionnaire:', error);
                        this.showError('Impossible de charger le questionnaire.');
                    }
                }

                async loadQuestions() {
                    const response = await fetch('questions.json');
                    if (!response.ok) {
                        throw new Error('Chargement du fichier questions.json impossible');
                    }
                    const data = await response.json();
                    this.questions = this.flattenQuestions(data);
                    this.totalMainQuestions = this.questions.filter((question) => this.isProgressQuestion(question)).length;
                }

                flattenQuestions(data) {
                    const flattened = [];
                    if (data && Array.isArray(data.sections)) {
                        data.sections.forEach((section) => {
                            if (section.questions && Array.isArray(section.questions)) {
                                section.questions.forEach((question) => {
                                    flattened.push({
                                        ...question,
                                        sectionId: section.id,
                                        sectionTitle: section.title || ''
                                    });
                                });
                            }
                        });
                    }
                    return flattened;
                }

                async startInterview() {
                    this.statusText.textContent = 'En cours...';
                    await this.generateIntroduction();
                    this.currentQuestionIndex = 0;
                    await this.askNextQuestion();
                }

                async generateIntroduction() {
                    this.botIsResponding = true;
                    this.showTyping();
                    try {
                        const prompt = "R√©dige un message d'introduction pour un questionnaire QVT interne. Mentionne qu'il y aura des questions ouvertes et des questions not√©es de 1 √† 5 avec l'√©chelle 1 = avis le plus n√©gatif, 5 = avis le plus positif. Encourage la sinc√©rit√© et ajoute une touche d'humour l√©g√®re. Pr√©cise que la premi√®re question est ouverte.";
                        const intro = await this.generateAIMessage(prompt);
                        if (intro) {
                            this.addMessage(intro, 'bot');
                        }
                    } catch (error) {
                        console.error("Erreur lors de la g√©n√©ration de l'introduction:", error);
                        this.showError("Erreur lors de la g√©n√©ration de l'introduction.");
                    } finally {
                        this.hideTyping();
                        this.botIsResponding = false;
                    }
                }

                async askNextQuestion() {
                    if (this.currentQuestionIndex >= this.questions.length) {
                        await this.completeSurvey();
                        return;
                    }

                    const question = this.questions[this.currentQuestionIndex];
                    await this.handleSectionTransition(question);

                    this.currentQuestion = question;
                    this.awaitingFollowup = false;
                    this.pendingFollowupQuestion = null;
                    this.pendingFollowupEntry = null;
                    this.lastRatingValue = null;

                    if (!this.timestampStart) {
                        this.timestampStart = new Date().toISOString();
                    }

                    if (question.type === 'open') {
                        await this.showOpenQuestion(question);
                    } else if (question.type === 'rating') {
                        await this.showRatingQuestion(question);
                    } else if (question.type === 'radio') {
                        await this.showRadioQuestion(question);
                    }
                }

                async handleSectionTransition(question) {
                    if (!question) {
                        return;
                    }

                    if (this.previousSectionId === null) {
                        this.previousSectionId = question.sectionId;
                        return;
                    }

                    if (question.sectionId === this.previousSectionId) {
                        return;
                    }

                    const previousSectionId = this.previousSectionId;
                    this.previousSectionId = question.sectionId;

                    let prompt = '';
                    const sanitizedTitle = this.sanitizeSectionTitle(question.sectionTitle || '');

                    if (previousSectionId === 'expr_libre_intro' && question.sectionId === 'bureautique_informatique') {
                        prompt = "Annonce la premi√®re section en introduisant le th√®me de la bureautique et utilise exactement la phrase 'Nous allons commencer par votre avis sur la bureautique.'. Reste bref et bienveillant.";
                    } else if (previousSectionId === 'espace_travail' && question.sectionId === 'conditions_travail') {
                        prompt = `Fais une transition marqu√©e vers la nouvelle th√©matique \"${sanitizedTitle}\" en utilisant une expression du type \"passons maintenant sur une partie tr√®s importante\". Reste concis et motivant.`;
                    } else if (question.sectionId === 'expr_libre_outro') {
                        prompt = "Annonce la derni√®re question ouverte en invitant √† partager d'ultimes suggestions, avec chaleur mais sans insister.";
                    } else if (question.sectionId === 'motivation' && previousSectionId !== 'motivation') {
                        prompt = `Fais une courte transition vers la th√©matique \"${sanitizedTitle}\" avec √©nergie, sans d√©voiler la question.`;
                    } else if (question.sectionId === 'profil') {
                        prompt = 'Indique que la derni√®re √©tape concerne le profil en rappelant de choisir une seule option. Reste tr√®s bref.';
                    } else {
                        prompt = `R√©alise une transition concise vers le th√®me \"${sanitizedTitle}\" sans citer de questions pr√©cises.`;
                    }

                    if (prompt) {
                        this.botIsResponding = true;
                        this.showTyping();
                        try {
                            const transition = await this.generateAIMessage(prompt);
                            if (transition) {
                                this.addMessage(transition, 'bot');
                            }
                        } catch (error) {
                            console.error('Erreur lors de la g√©n√©ration de la transition:', error);
                        } finally {
                            this.hideTyping();
                            this.botIsResponding = false;
                        }
                    }
                }

                sanitizeSectionTitle(title) {
                    return (title || '').replace(/^[^A-Za-z√Ä-√ñ√ò-√∂√∏-√ø0-9]+/u, '').trim();
                }

                isProgressQuestion(question) {
                    return question && question.type !== 'open';
                }

                async showOpenQuestion(question) {
                    this.chatInput.disabled = true;
                    this.sendButton.disabled = true;
                    await this.displayBotMessage(question.text);
                    this.inputContainer.style.display = 'block';
                    this.chatInput.disabled = false;
                    this.chatInput.value = '';
                    this.chatInput.placeholder = 'Tapez votre r√©ponse...';
                    this.sendButton.disabled = true;
                    this.chatInput.focus();
                }

                async showRatingQuestion(question) {
                    const scale = this.getScaleInfo(question);
                    await this.displayBotMessage(question.text);

                    const ratingContainer = this.createRatingButtons(question, scale);
                    this.inputContainer.style.display = 'none';
                    this.chatMessages.appendChild(ratingContainer);
                    this.scrollToBottom();
                }

                getScaleInfo(question) {
                    const lowerText = (question.text || '').toLowerCase();
                    let leftLabel = '1 = Avis le plus n√©gatif';
                    let rightLabel = '5 = Avis le plus positif';
                    let explanation = '1 = avis le plus n√©gatif ¬∑ 5 = avis le plus positif';

                    if (lowerText.includes('satisfait')) {
                        leftLabel = '1 = Pas du tout satisfait(e)';
                        rightLabel = '5 = Tr√®s satisfait(e)';
                        explanation = '1 = Pas du tout satisfait(e) ¬∑ 5 = Tr√®s satisfait(e)';
                    } else if (lowerText.includes('stress')) {
                        leftLabel = '1 = Tr√®s stress√©(e)';
                        rightLabel = '5 = Pas du tout stress√©(e)';
                        explanation = '1 = Tr√®s stress√©(e) ¬∑ 5 = Pas du tout stress√©(e)';
                    } else if (lowerText.includes('sens')) {
                        leftLabel = '1 = Peu de sens';
                        rightLabel = '5 = Beaucoup de sens';
                        explanation = '1 = Peu de sens ¬∑ 5 = Beaucoup de sens';
                    } else if (lowerText.includes('raisonnable') || lowerText.includes('adapt√©e')) {
                        leftLabel = '1 = Pas du tout adapt√©e';
                        rightLabel = '5 = Parfaitement adapt√©e';
                        explanation = '1 = Pas du tout adapt√©e ¬∑ 5 = Parfaitement adapt√©e';
                    } else if (lowerText.includes('missions') || lowerText.includes('claires')) {
                        leftLabel = '1 = Pas claires du tout';
                        rightLabel = '5 = Tr√®s claires';
                        explanation = '1 = Pas claires du tout ¬∑ 5 = Tr√®s claires';
                    } else if (lowerText.includes('motiv√©')) {
                        leftLabel = '1 = Pas du tout motiv√©(e)';
                        rightLabel = '5 = Tr√®s motiv√©(e)';
                        explanation = '1 = Pas du tout motiv√©(e) ¬∑ 5 = Tr√®s motiv√©(e)';
                    } else if (lowerText.includes('reconnu')) {
                        leftLabel = '1 = Pas du tout reconnu(e)';
                        rightLabel = '5 = Tr√®s reconnu(e)';
                        explanation = '1 = Pas du tout reconnu(e) ¬∑ 5 = Tr√®s reconnu(e)';
                    } else if (lowerText.includes('qualit√©')) {
                        leftLabel = '1 = Tr√®s mauvaise';
                        rightLabel = '5 = Excellente';
                        explanation = '1 = Tr√®s mauvaise ¬∑ 5 = Excellente';
                    } else if (lowerText.includes('concilier') || lowerText.includes('√©quilibre')) {
                        leftLabel = '1 = Pas du tout';
                        rightLabel = '5 = Parfaitement';
                        explanation = '1 = Pas du tout ¬∑ 5 = Parfaitement';
                    } else if (lowerText.includes('moyens n√©cessaires')) {
                        leftLabel = '1 = Pas du tout';
                        rightLabel = '5 = Compl√®tement';
                        explanation = '1 = Pas du tout ¬∑ 5 = Compl√®tement';
                    }

                    return {
                        leftLabel,
                        rightLabel,
                        explanation
                    };
                }

                createRatingButtons(question, scale) {
                    const container = document.createElement('div');
                    container.className = 'rating-options';

                    const title = document.createElement('div');
                    title.className = 'rating-title';
                    title.textContent = 'Cliquez sur votre note :';
                    container.appendChild(title);

                    const buttonsWrapper = document.createElement('div');
                    buttonsWrapper.className = 'rating-buttons';

                    for (let i = 1; i <= 5; i++) {
                        const button = document.createElement('button');
                        button.className = 'rating-btn';
                        button.type = 'button';
                        button.textContent = i.toString();
                        button.addEventListener('click', () => {
                            this.handleRatingSelection(question, i, container).catch((error) => {
                                console.error('Erreur lors du traitement de la note:', error);
                                this.showError("Une erreur est survenue lors de l'enregistrement de la note.");
                            });
                        });
                        buttonsWrapper.appendChild(button);
                    }

                    container.appendChild(buttonsWrapper);

                    const labelsContainer = document.createElement('div');
                    labelsContainer.className = 'rating-labels';
                    labelsContainer.innerHTML = `<span>${scale.leftLabel}</span><span>${scale.rightLabel}</span>`;
                    container.appendChild(labelsContainer);

                    return container;
                }
                async handleRatingSelection(question, value, container) {
                    this.addMessage(value.toString(), 'user');
                    const timestamp = new Date().toISOString();

                    const entry = {
                        id: question.id,
                        type: 'rating',
                        question: question.text,
                        answer: value.toString(),
                        followup: '',
                        timestamp
                    };
                    this.responses.push(entry);
                    this.answersById[question.id] = {
                        value: value.toString(),
                        followup: ''
                    };

                    if (this.isProgressQuestion(question)) {
                        this.completedMainQuestions += 1;
                        this.updateProgress();
                    }

                    container.remove();
                    this.lastRatingValue = value;

                    if (value <= 2) {
                        this.awaitingFollowup = true;
                        this.pendingFollowupQuestion = question;
                        this.pendingFollowupEntry = entry;
                        await this.generateFollowup(question, value);
                    } else {
                        if ((value === 5 || value === 4) && this.shouldSendPerfectScoreReaction()) {
                            await this.sendPerfectScoreReaction(question,value);
                        }
                        await this.moveToNextQuestion();
                    }
                }

                shouldSendPerfectScoreReaction() {
                    return Math.random() < this.perfectScoreReactionChance;
                }

                shouldSendFollowupReaction() {
                    this.followupReactionToggle = !this.followupReactionToggle;
                    return this.followupReactionToggle;
                }

                async sendPerfectScoreReaction(question, rating) {
                    this.botIsResponding = true;
                    this.showTyping();
                    try {
                        const prompt = `Un participant vient d'attribuer la tr√®s bonne note de ${rating}/5 √† la question suivante : "${question.text}". Compose une r√©action tr√®s courte du chatbot : f√©licite avec enthousiasme, ajoute une pointe d'humour l√©g√®re + √©mojies et n'inclus aucune question ni nouvelle consigne.`;
                        let quip = await this.generateAIMessage(prompt);
                        if (!quip || !quip.trim()) {
                            quip = "5/5 ? Je note √ßa dans mon carnet des bonnes nouvelles !";
                        }
                        const delayDuration = this.calculateTypingDelay(quip);
                        await this.delay(delayDuration);
                        this.addMessage(quip, 'bot');
                    } catch (error) {
                        console.error('Erreur lors de l\'affichage de la r√©action 5/5:', error);
                        const fallback = "5/5, et me voil√† tout sourire derri√®re l'√©cran !";
                        const delayDuration = this.calculateTypingDelay(fallback);
                        await this.delay(delayDuration);
                        this.addMessage(fallback, 'bot');
                    } finally {
                        this.hideTyping();
                        this.botIsResponding = false;
                    }
                }

                async generateFollowup(question, rating) {
                    this.botIsResponding = true;
                    this.showTyping();
                    try {
						const prompt = `L'utilisateur a attribu√© la note ${rating}/5 √† la question suivante¬†: "${question.text}". R√©dige une unique question de relance ouverte, courte et empathique. Le ton doit rester s√©rieux, sans humour ni emoji, afin de comprendre pourquoi la note est basse. N'ajoute aucune autre consigne ni deuxi√®me question.`;
                        const followup = await this.generateAIMessage(prompt);
                        if (followup) {
                            this.addMessage(followup, 'bot');
                        }
                        this.inputContainer.style.display = 'block';
                        this.chatInput.disabled = false;
                        this.chatInput.value = '';
                        this.chatInput.placeholder = 'D√©crivez bri√®vement votre ressenti...';
                        this.sendButton.disabled = true;
                        this.chatInput.focus();
                    } catch (error) {
                        console.error('Erreur lors de la g√©n√©ration de la relance:', error);
                        this.showError('Impossible de g√©n√©rer la relance.');
                        this.awaitingFollowup = false;
                        if (this.pendingFollowupQuestion) {
                            await this.moveToNextQuestion();
                        }
                    } finally {
                        this.hideTyping();
                        this.botIsResponding = false;
                    }
                }

                async handleFollowupAnswer(text) {
                    if (!this.pendingFollowupQuestion || !this.pendingFollowupEntry) {
                        return;
                    }

                    const question = this.pendingFollowupQuestion;
                    const entry = this.pendingFollowupEntry;

                    if (question && this.answersById[question.id]) {
                        this.answersById[question.id].followup = text;
                    }
                    if (entry) {
                        entry.followup = text;
                    }

                    if (question && this.shouldSendFollowupReaction()) {
                        await this.sendFollowupReaction(question, text);
                    }

                    this.awaitingFollowup = false;
                    this.pendingFollowupQuestion = null;
                    this.pendingFollowupEntry = null;

                    await this.moveToNextQuestion();
                }

                async sendFollowupReaction(question, userAnswer) {
                    this.botIsResponding = true;
                    this.showTyping();
                    try {
                        const sanitizedAnswer = (userAnswer || '').replace(/\s+/g, ' ').trim();
                        const prompt = `Voici la question du questionnaire QVT : "${question.text}". L'utilisateur a donn√© une note de 1 ou 2 puis a expliqu√© son ressenti ainsi : "${sanitizedAnswer}". Formule une r√©action tr√®s courte (une √† deux phrases maximum), chaleureuse et empathique. Ne pose aucune question, n'ajoute aucune consigne et n'utilise pas d'emoji.`;
                        let reaction = await this.generateAIMessage(prompt);
                        if (!reaction || !reaction.trim()) {
                            reaction = "Je comprends, merci d'avoir pris le temps de m'expliquer ce ressenti.";
                        }
                        const delayDuration = this.calculateTypingDelay(reaction);
                        await this.delay(delayDuration);
                        this.addMessage(reaction, 'bot');
                    } catch (error) {
                        console.error('Erreur lors de la r√©action empathique:', error);
                        const fallback = "Merci pour votre franchise, je prends bien note de ce que vous traversez.";
                        const delayDuration = this.calculateTypingDelay(fallback);
                        await this.delay(delayDuration);
                        this.addMessage(fallback, 'bot');
                    } finally {
                        this.hideTyping();
                        this.botIsResponding = false;
                    }
                }

                async showRadioQuestion(question) {
                    await this.displayBotMessage(question.text);
                    const radioContainer = this.createRadioContainer(question);
                    this.inputContainer.style.display = 'none';
                    this.chatMessages.appendChild(radioContainer);
                    this.scrollToBottom();
                }

                createRadioContainer(question) {
                    const container = document.createElement('div');
                    container.className = 'radio-options';

                    const prompt = document.createElement('div');
                    prompt.style.marginBottom = '15px';
                    prompt.style.fontWeight = 'bold';
                    prompt.style.fontSize = '14px';
                    prompt.textContent = 'S√©lectionnez votre r√©ponse :';
                    container.appendChild(prompt);

                    const name = 'radio_' + question.id + '_' + Date.now();
                    const options = Array.isArray(question.options) ? question.options : [];

                    options.forEach((option, index) => {
                        const optionWrapper = document.createElement('div');
                        optionWrapper.className = 'radio-option';

                        const input = document.createElement('input');
                        input.type = 'radio';
                        input.name = name;
                        input.value = option;
                        input.id = `${name}_${index}`;

                        const label = document.createElement('label');
                        label.htmlFor = input.id;
                        label.textContent = option;

                        optionWrapper.appendChild(input);
                        optionWrapper.appendChild(label);

                        optionWrapper.addEventListener('click', () => {
                            input.checked = true;
                            submitBtn.disabled = false;
                            container.querySelectorAll('.radio-option').forEach((node) => {
                                node.style.backgroundColor = '';
                            });
                            optionWrapper.style.backgroundColor = '#e3f2fd';
                        });

                        container.appendChild(optionWrapper);
                    });

                    const submitBtn = document.createElement('button');
                    submitBtn.className = 'radio-submit-btn';
                    submitBtn.type = 'button';
                    submitBtn.textContent = 'Valider ma r√©ponse';
                    submitBtn.disabled = true;
                    submitBtn.addEventListener('click', () => {
                        const selected = container.querySelector(`input[name="${name}"]:checked`);
                        if (selected) {
                            this.handleRadioSelection(question, selected.value, container).catch((error) => {
                                console.error('Erreur lors de la s√©lection radio:', error);
                                this.showError("Impossible d'enregistrer cette r√©ponse.");
                            });
                        }
                    });
                    container.appendChild(submitBtn);

                    return container;
                }

                async handleRadioSelection(question, value, container) {
                    this.addMessage(value, 'user');
                    const timestamp = new Date().toISOString();

                    const entry = {
                        id: question.id,
                        type: 'radio',
                        question: question.text,
                        answer: value,
                        timestamp
                    };
                    this.responses.push(entry);
                    this.answersById[question.id] = {
                        value,
                        followup: ''
                    };

                    if (this.isProgressQuestion(question)) {
                        this.completedMainQuestions += 1;
                        this.updateProgress();
                    }

                    container.remove();
                    await this.moveToNextQuestion();
                }

                async sendMessage() {
                    const message = this.chatInput.value.trim();
                    if (!message) {
                        return;
                    }

                    this.addMessage(message, 'user');
                    this.chatInput.value = '';
                    this.chatInput.disabled = true;
                    this.sendButton.disabled = true;

                    if (this.awaitingFollowup) {
                        await this.handleFollowupAnswer(message);
                        return;
                    }

                    if (this.currentQuestion && this.currentQuestion.type === 'open') {
                        await this.handleOpenResponse(this.currentQuestion, message);
                    }
                }

                async handleOpenResponse(question, text) {
                    const timestamp = new Date().toISOString();
                    const entry = {
                        id: question.id,
                        type: 'open',
                        question: question.text,
                        answer: text,
                        timestamp
                    };

                    this.responses.push(entry);
                    this.answersById[question.id] = {
                        value: text,
                        followup: ''
                    };

                    await this.moveToNextQuestion();
                }

                async moveToNextQuestion() {
                    this.currentQuestionIndex += 1;
                    if (this.currentQuestionIndex >= this.questions.length) {
                        await this.completeSurvey();
                        return;
                    }
                    await this.askNextQuestion();
                }

                async completeSurvey() {
                    if (this.isCompleted) {
                        return;
                    }
                    this.isCompleted = true;
                    this.timestampEnd = new Date().toISOString();

                    await this.generateClosingMessage();
                    await this.saveResponses();

                    this.statusText.textContent = 'Termin√© ‚úÖ';
                    this.updateProgress(100);
                    this.showCompletion();
                }

                async generateClosingMessage() {
                    this.botIsResponding = true;
                    this.showTyping();
                    try {
                        const prompt = 'Le questionnaire est termin√©. R√©dige un remerciement chaleureux et concis, puis termine exactement par la phrase : "Ceci conclut notre entretien. Merci pour votre participation."';
                        const closing = await this.generateAIMessage(prompt);
                        if (closing) {
                            this.addMessage(closing, 'bot');
                        }
                    } catch (error) {
                        console.error('Erreur lors de la g√©n√©ration du message de cl√¥ture:', error);
                    } finally {
                        this.hideTyping();
                        this.botIsResponding = false;
                    }
                }

                buildStructuredAnswers() {
                    return {
                        timestampStart: this.timestampStart,
                        timestampEnd: this.timestampEnd,
                        answers: this.answersById
                    };
                }

                async saveResponses() {
                    try {
                        const payload = {
                            sessionId: this.sessionId,
                            responses: this.responses,
                            userInfo: {
                                userAgent: navigator.userAgent,
                                completedAt: this.timestampEnd
                            },
                            timestampStart: this.timestampStart,
                            timestampEnd: this.timestampEnd,
                            structuredAnswers: this.buildStructuredAnswers()
                        };

                        const response = await fetch('/api/save-responses', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`Erreur HTTP ${response.status}`);
                        }

                        await this.saveResponsesToCsv(payload.structuredAnswers);
                    } catch (error) {
                        console.error('Erreur lors de la sauvegarde des r√©ponses:', error);
                        this.showError('Questionnaire termin√©, mais la sauvegarde a √©chou√©.');
                    }
                }

                async saveResponsesToCsv(structuredAnswers) {
                    const payload = {
                        sessionId: this.sessionId,
                        timestampStart: this.timestampStart,
                        timestampEnd: this.timestampEnd,
                        structuredAnswers
                    };

                    const response = await fetch('savecsv.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ${response.status}`);
                    }

                    try {
                        const result = await response.json();
                        if (!result || result.success !== true) {
                            throw new Error('R√©ponse CSV invalide');
                        }
                    } catch (error) {
                        throw new Error('R√©ponse CSV invalide');
                    }
                }

                async generateAIMessage(prompt) {
                    const conversation = this.aiConversation.concat({
                        role: 'user',
                        content: prompt
                    });

                    const response = await this.callAPI(conversation);

                    this.aiConversation.push({
                        role: 'user',
                        content: prompt
                    });
                    this.aiConversation.push({
                        role: 'assistant',
                        content: response
                    });

                    return response;
                }

                async callAPI(messages) {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages,
                            sessionId: this.sessionId
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Erreur HTTP ' + response.status);
                    }

                    const data = await response.json();
                    return data.response;
                }

                addMessage(content, sender) {
                    const messageElement = document.createElement('div');
                    messageElement.className = 'message ' + (sender === 'user' ? 'user' : 'bot');
                    messageElement.innerHTML = this.escapeHtml(content).replace(/\n/g, '<br>');
                    this.chatMessages.appendChild(messageElement);
                    this.scrollToBottom();
                }

                delay(ms) {
                    return new Promise((resolve) => {
                        setTimeout(resolve, ms);
                    });
                }

                calculateTypingDelay(text = '') {
                    const length = (text || '').length;
                    const min = this.typingDelayConfig.min;
                    const max = this.typingDelayConfig.max;
                    const perChar = this.typingDelayConfig.perChar;
                    const estimated = length * perChar;
                    return Math.min(max, Math.max(min, estimated));
                }

                async displayBotMessage(text) {
                    const message = text || '';
                    const delayDuration = this.calculateTypingDelay(message);
                    this.botIsResponding = true;
                    this.showTyping();
                    await this.delay(delayDuration);
                    this.hideTyping();
                    this.addMessage(message, 'bot');
                    this.botIsResponding = false;
                }

                escapeHtml(text) {
                    return (text || '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                }

                showTyping() {
                    this.typingIndicator.style.display = 'block';
                    this.chatMessages.appendChild(this.typingIndicator);
                    this.scrollToBottom();
                }

                hideTyping() {
                    this.typingIndicator.style.display = 'none';
                }

                updateProgress(customValue = null) {
                    let progress = 0;
                    if (customValue !== null) {
                        progress = customValue;
                    } else if (this.totalMainQuestions > 0) {
                        progress = Math.min((this.completedMainQuestions / this.totalMainQuestions) * 100, 100);
                    }
                    this.progressFill.style.width = progress + '%';
                }

                scrollToBottom() {
                    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                }

                showError(message) {
                    this.errorMessage.textContent = message;
                    this.errorMessage.style.display = 'block';
                    setTimeout(() => {
                        this.hideError();
                    }, 5000);
                }

                hideError() {
                    this.errorMessage.style.display = 'none';
                }

                showCompletion() {
                    this.completionMessage.style.display = 'block';
                    this.inputContainer.style.display = 'none';
                    setTimeout(() => {
                        this.chatMessages.appendChild(this.completionMessage);
                        this.scrollToBottom();
                    }, 300);
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                new SurveyChatbot();
            });
        })();
    </script>
</body>
</html>